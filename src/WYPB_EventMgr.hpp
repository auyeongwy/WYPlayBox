/*      
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*  http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.    
*/



#ifndef _WYPB_EVENT_MGR_H_
#define _WYPB_EVENT_MGR_H_

#include "WYPB_Event.hpp"
#include "WYPB_PlayerMgr.hpp"


/** An event manager class to manage and schedule events generated.
 * 
 * 2 event queues are managed internally. A current queue where events are sent to player objects. And a backup queue which receives events generated by player objects (or others) which the current event queue is processed. This avoids an infinite loop while processing the current event queue and allows our simulation a chance to pause and process the existing state of the simulation.
 *   
 * Once the current queue finished processing, the current queue and backup queues automatically switch.
 * 
 * E.g.
 * 
 * try {
 *  WYPB_EventMgr event_mgr_obj;
 *  .... (other processing)
 *  add_event(*event_obj1) // add events
 *  add_event(*event_obj2)
 *  ......
 *  process_all_events(); // process all events in the current event queue. 
 *                        // While this is happening, other objects may be calling add_event() to add events to the backup event queue.
 *                        // Once process_all_events() completes, the current queue is emptied and switches with the backup queue. 
 *                        // All events in the current queue are also freed.
 * }
 * 
 * 
*/

class WYPB_PlayerMgr;

class WYPB_EventMgr
{
public:
    /** Contructor.
     * 
     * \param p_max_events Number of total events each event queue can store.
     * \throws Integer exception upon error. See WYPB_Exception.h for details. 
    */
    WYPB_EventMgr(const unsigned long p_max_events=1024);


    /** Destructor.
    */
    ~WYPB_EventMgr(void);


    /** Adds an event to the backup event. 
     * 
     * \param p_event Dynamically allocated WYPB_Event. Must be dynamically allocated or we'll run into memory errors.
     * \returns 0 for no error. Else integer exception - see WYPB_Exception.h.
    */
    int add_event(WYPB_Event* const p_event) noexcept;


    /** Process all events in the current event queue by sending all events to relevant objects.
     * Note that one all events are processed in the current queue, 2 things happen: \n
     * (1) All events in the current queue are freed. Player objects which want to retain the event must save their own copy. \n
     * (2) The current queue switches with the backup queue. \n
     * \param p_player_mgr The WYPB_PlayerMgr object that will process the current list of events.
     * \param p_event_mgr When new events are generated by this function call, this is the WYPB_EventMgr object that will receive and queue the new events.
    */
    void process_all_events(WYPB_PlayerMgr * const p_player_mgr, WYPB_EventMgr * const p_event_mgr) noexcept;


private:
    unsigned long m_max_events; /**< Max number of events in a queue. */
    unsigned long m_num_events[2]; /**< Current number of events in each queue. E.g. m_num_events[0] is num of events in m_event_queue[0]. */
    unsigned long m_current_queue; /**< Index of the event queue to be processed. */
    unsigned long m_backup_queue; /**< Index of the event queue where new events are queued. */
    WYPB_Event** m_event_queue[2]; /**< The event queues. */
};


#endif